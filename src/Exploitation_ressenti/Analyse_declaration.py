# -*- coding: utf-8 -*-
"""
Created on 30 mars 2023

@author: martin.schoreisz
module d'analyse des resultats de declaration traites dans le module Import_stockage_donnees.Import_export_bdd.
"""

import pandas as pd
import numpy as np
from datetime import timedelta
from Outils.Outils import checkParamValues, dateTexteDepuisDayOfYear, checkAttributsinDf
import altair as alt
from collections import Counter
from math import log


def filtrerDeclas(
    instanceResultatsEnquete,
    dateDebut="2022-03-21",
    dateFin="2022-04-17",
    dureeMaxiDeclaEnHeure=24,
    typeDeBruit="Bruit routier",
    site=None,
):
    """
    limite les donnees  la periode de mesures et aux declaration qui ne couvrent pas l'ensemble de la periode
    in :
        instanceResultatsEnquete instance de la classe Import_stockage_donnees.Import_export_bdd.ResultatsEnquete
        dateDebut : string format YYYY-MM-DD : date de debut de la collecte
        dateFin : string format YYYY-MM-DD : date de fin de la collecte
        dureeMaxiDeclaEnHeure : integer : duree maximale en heure totale pour une declaration. Au dela la decla est filtre
    out :
        data farme sur le modele de ResultatsEnquete.declarations_ok
    """
    checkParamValues(
        typeDeBruit,
        ("Bruit routier", "Bruit de voisinage", "Bruit de chantier", "Autre"),
    )
    if not site:
        declas = instanceResultatsEnquete.declarations_ok.loc[
            (
                instanceResultatsEnquete.declarations_ok.debut_gene.dt.date.isin(
                    [e.date() for e in pd.date_range(dateDebut, dateFin)]
                )
            )
            & (
                instanceResultatsEnquete.declarations_ok.duree_gene
                < timedelta(hours=dureeMaxiDeclaEnHeure)
            )
            & (
                instanceResultatsEnquete.declarations_ok.source_bruit.apply(
                    lambda x: typeDeBruit in x if x else True
                )
            )
        ].copy()
    else:
        declas = instanceResultatsEnquete.declarations_ok.loc[
            (
                instanceResultatsEnquete.declarations_ok.debut_gene.dt.date.isin(
                    [e.date() for e in pd.date_range(dateDebut, dateFin)]
                )
            )
            & (
                instanceResultatsEnquete.declarations_ok.duree_gene
                < timedelta(hours=dureeMaxiDeclaEnHeure)
            )
            & (
                instanceResultatsEnquete.declarations_ok.source_bruit.apply(
                    lambda x: typeDeBruit in x if x else True
                )
            )
            & (instanceResultatsEnquete.declarations_ok.id_instru_site_ref == site)
        ].copy()
    return declas


def passageDeclas6min(
    dfDecla,
    dateDebut="2022-03-21",
    dateFin="2022-04-18",
    annee=2022,
    pasTemporel="6 min",
):
    """
    passage des donnees de declaration en debut / fin vers des donnees a intervalles regulier
    in :
       dfDecla : dataframe issue de  filtrerDeclas
    """
    checkAttributsinDf(dfDecla, ["debut_gene", "fin_gene"])
    dfToutTemps = dfDecla.merge(
        pd.Series(
            pd.date_range(dateDebut, dateFin, freq=pasTemporel), name="date_heure"
        ),
        how="cross",
    )
    dfToutTemps = dfToutTemps.loc[
        (dfToutTemps.date_heure >= dfToutTemps.debut_gene)
        & (dfToutTemps.date_heure <= dfToutTemps.fin_gene)
    ].copy()
    dfToutTemps["date_gene"] = dfToutTemps.date_heure.dt.dayofyear
    dfToutTemps["date_gene_texte"] = dfToutTemps.date_gene.apply(
        lambda x: dateTexteDepuisDayOfYear(x, annee, formatSortie="%A %d %B")
    )
    return dfToutTemps


def nbParticipantParJour(dfDecla):
    """
    creer une df du nombre de déclarant distinct par jour.
    in :
        dfDecla : df issue de passageDeclas6min()
    """
    checkAttributsinDf(dfDecla, ["date_gene", "id_participant"])
    return (
        dfDecla.drop_duplicates(["date_gene", "id_participant"])
        .groupby(["date_gene", "date_gene_texte"])
        .id_participant.count()
        .reset_index().rename(columns={'id_participant': 'nb_participants'})
    )


def nbParticipantParPasTemp(dfParticipantParJour, pasTemp, refTemp='01-01-2022'):
    """
    denseifier la df de participants par jour, selon un pas temporel choisi, avec la fonction fffill de resample
    in
        dfParticipantParJour : df issue de nbParticipantParJour(). doit avoir un attr date_gene qui est un dayofyear
        pasTemp : pas temporel selon les précos de la fonction resample de panda
        refTemp : string de date marquant le début de l'année de ref pour l'attr date_gene 
    """
    checkAttributsinDf(dfParticipantParJour, 'date_gene')
    return dfParticipantParJour.set_index(pd.to_datetime(dfParticipantParJour.date_gene, unit='D', origin=pd.Timestamp(refTemp))).resample(pasTemp).ffill()


def grouperDeclaParHorodate(dfDecla6Min):
    """
    Agrégation des données de façon à n'avoir qu'une seule ligne par par de 6 minutes
    on va calculer les indicateurs statistiques classiques : écart_type min, max, moyenne, nombre de vote
    on ne pernd pas la médiane, car les votes "extrême" reste des informatiosn à ne pas considérer comme déviantes
    in:
        dfDecla6Min : df issue de passageDeclas6min
    out :
        df avec une seule ligne par horodate et des agregats
    """
    dfToutTempsIndics = (
        dfDecla6Min.groupby("date_heure")
        .note_gene.agg(
            [
                np.std,
                lambda x: tuple(x),
                np.mean,
                lambda x: len(x),
                lambda x: Counter(x),
                np.min,
                np.max,
                np.var,
            ]
        )
        .rename(
            columns={
                "std": "ecart_type",
                "<lambda_0>": "valeurs",
                "mean": "moyenne",
                "<lambda_1>": "nb_val",
                "<lambda_2>": "nb_occ",
                "amin": "note_min",
                "amax": "note_max",
            }
        )
        .reset_index()
    )
    # analyse d'un jour
    dfToutTempsIndics["date_gene"] = dfToutTempsIndics.date_heure.dt.dayofyear
    return dfToutTempsIndics


def ajouterIndicateursTest(dfDecla6MinGroupee):
    """
    ajouter les attributs de cumul des notes, cumul de note ponderees, moyenne pondérée, moyenne pondérée avec note note pondérée,
    moyenne pondérée avec pondération pondérée
    """
    dfToutTempsIndics = dfDecla6MinGroupee.copy()
    dfToutTempsIndics["note_cumul"] = dfToutTempsIndics.nb_occ.apply(
        lambda x: sum([k * v for k, v in x.items()])
    )
    dfToutTempsIndics["note_pondere_std"] = dfToutTempsIndics.apply(
        lambda x: (
            1.5
            / (
                x.ecart_type
                if (not pd.isnull(x.ecart_type) and x.ecart_type != 0)
                else 1.5 - (x.nb_val * 0.1)
            )
        )
        * x.nb_val
        * x.moyenne,
        axis=1,
    )
    dfToutTempsIndics["nb_note"] = dfToutTempsIndics.nb_occ.apply(
        lambda x: sum([v for v in x.values()])
    )
    dfMoyennePonderee = dfToutTempsIndics.assign(
        moy_pond_sur_k=dfToutTempsIndics.apply(
            lambda x: (sum([(k + log(v / 2)) * pow(v, 2) for k, v in x.nb_occ.items()]))
            / sum([pow(v, 2) for v in x.nb_occ.values()]),
            axis=1,
        ),
        moy_pond_sur_v=dfToutTempsIndics.apply(
            lambda x: (sum([(k) * pow(v + log(v / 2), 2) for k, v in x.nb_occ.items()]))
            / sum([pow(v + log(v / 2), 2) for v in x.nb_occ.values()]),
            axis=1,
        ),
        moy_pond=dfToutTempsIndics.apply(
            lambda x: (sum([(k) * pow(v, 2) for k, v in x.nb_occ.items()]))
            / sum([pow(v, 2) for v in x.nb_occ.values()]),
            axis=1,
        ),
    )
    return dfMoyennePonderee


def ajouterMoyennePonderee(dfDecla6MinGroupee, nbVotantRepresentatif=2):
    """
    ajouter la moyenne pondérée par terme correctif sur la note en fonction du nombre de votant.
    in:
        nbVotantRepresentatif : nombre de votant à partir duquel on considère que la note est représentative
    """
    checkAttributsinDf(dfDecla6MinGroupee, "nb_occ")
    dfDecla6MinGroupee[
        f"moy_pond_{nbVotantRepresentatif}Votants"
    ] = dfDecla6MinGroupee.apply(
        lambda x: (
            sum(
                [
                    (k + log(v / nbVotantRepresentatif)) * pow(v, nbVotantRepresentatif)
                    for k, v in x.nb_occ.items()
                ]
            )
        )
        / sum([pow(v, nbVotantRepresentatif) for v in x.nb_occ.values()]),
        axis=1,
    )
    return dfDecla6MinGroupee


def graphNbVotantParJour(dfDecla6Min):
    """
    creer le graph de visu du nombre de votant par jour
    in:
        dfDecla6Min : df issue de passageDeclas6min
    out:
        chart altair
    """
    # mise en forme des données
    dfNbParticipantParJour = (
        dfDecla6Min.drop_duplicates(["date_gene", "id_participant"])
        .groupby(["date_gene", "date_gene_texte"])
        .id_participant.count()
        .reset_index()
    )
    # chart nombre de participants par jour
    chartEvolNbParticipantsParJour = (
        alt.Chart(dfNbParticipantParJour, title="Nombre de participants par jour")
        .mark_line()
        .encode(
            x=alt.X("date_gene_texte", title=None, sort=alt.SortField("date_gene")),
            y=alt.Y("id_participant", title="Nombre de participants par jour"),
        )
    )
    return chartEvolNbParticipantsParJour


def graphEvolutionMoyMinMaxStd(
    dfDecla6MinGroupee, domain=(0, 10), largeur=1200, hauteur=400
):
    """
    graph sur l'ensemble de la période de mesure, présentant les variations de notes fournies
    in :
        dfDecla6MinGroupee : df issue de grouperDeclaParHorodate()
    out:
        chart altair
    """
    base = alt.Chart(dfDecla6MinGroupee).encode(x=alt.X("date_heure:T", title="Date"))
    noteMoyenne = base.mark_trail().encode(
        y=alt.Y("moyenne", title="Note", scale=alt.Scale(zero=True, domain=domain)),
        size=alt.Size(
            "nb_val",
            title=["Nombre de", "déclarations"],
            scale=alt.Scale(rangeMin=0.7, rangeMax=6),
        ),
    )
    rangeNote = base.mark_area(opacity=0.5, color="#BCBCBC").encode(
        y=alt.Y("note_max", title="Note", scale=alt.Scale(domain=domain)), y2="note_min"
    )
    ecartType = base.mark_line(color="black").encode(
        y=alt.Y("ecart_type", title="Note", scale=alt.Scale(domain=domain))
    )
    return (noteMoyenne + rangeNote + ecartType).properties(
        title=[
            "Évolution de la moyenne, du maximum et du minimum des notes",
            "ainsi que de l'écart type",
        ],
        width=largeur,
        height=hauteur,
    )


def graphMoyennesPonderees(
    dfMoyennePonderee,
    listAttributs=["moyenne", "moy_pond", "moy_pond_sur_k", "moy_pond_sur_v"],
    largeur=500,
    domain=(4, 10),
):
    """
    création du graph représentant une ou plusieurs moyennes pondérées
    in:
       dfMoyennePonderee: datafarme issue de  ajouterIndicateursTest
       listAttributs : list de string des attributs à représenter
       domain : tuple de int : domaine de valeur sur l'axe y
    """
    return (
        alt.Chart(dfMoyennePonderee, width=largeur)
        .transform_fold(listAttributs)
        .mark_line()
        .encode(
            x=alt.X("date_heure:T"),
            y=alt.Y("value:Q", scale=alt.Scale(domain=domain)),
            color="key:N",
        )
    )


def creerChartDeclaHeureMinute(
    df, noteCumulee=True, largeur=500, hauteur=200, domainMax=120
):
    """
    créer une chart qui va compiler le nombre de déclaration de gene, pour une note données
    à un moment donnée d'une journée donnée. Si envie peux aussi fournir une note cumulée
    in :
        df : doit contenir les attributs 'id_participant', 'date_heure', 'note_gene', 'date_gene_texte'
    """
    titre = ["Gêne selon la journée"]
    dfGroupee = (
        df[
            [
                "id_participant",
                "date_heure",
                "note_gene",
                "date_gene_texte",
                "date_gene",
            ]
        ]
        .groupby(["date_heure", "note_gene", "date_gene_texte", "date_gene"])
        .id_participant.count()
        .reset_index()
        .sort_values("date_heure")
        .rename(columns={"id_participant": "nb_participants"})
    )
    if noteCumulee:
        dfNoteCumulee = (
            dfGroupee.groupby(["date_heure", "date_gene_texte", "date_gene"])
            .apply(
                lambda x: sum([n * p for n, p in zip(x.note_gene, x.nb_participants)])
            )
            .reset_index()
            .rename(columns={0: "coeff_pondere"})
        )
        dfMergee = dfGroupee.merge(
            dfNoteCumulee[["date_heure", "coeff_pondere"]], on="date_heure"
        )
        baseChart = alt.Chart(
            dfMergee, width=largeur, height=hauteur, title=titre
        ).encode(
            x=alt.X(
                "hoursminutes(date_heure):T",
                title="Heure",
                axis=alt.Axis(bandPosition=0),
            )
        )
        chartNbDecla = baseChart.mark_circle().encode(
            y=alt.Y(
                "note_gene",
                title="Note de gêne",
                scale=alt.Scale(zero=True, domainMax=10),
            ),
            color=alt.Color("nb_participants:N", title="Nombre de participant"),
            size="nb_participants:N",
        )
        chartNoteCumulee = baseChart.mark_line(color="black").encode(
            x=alt.X(
                "hoursminutes(date_heure):T",
                title="Heure",
                axis=alt.Axis(bandPosition=0),
            ),
            y=alt.Y(
                "coeff_pondere",
                title="Coefficient pondéré",
                scale=alt.Scale(zero=True, domainMax=domainMax),
            ),
        )
        return (
            (chartNbDecla + chartNoteCumulee)
            .resolve_scale(y="independent")
            .resolve_axis(x="shared")
        )
    else:
        return (
            alt.Chart(dfGroupee, width=largeur, height=hauteur, title=titre)
            .mark_circle()
            .encode(
                x=alt.X(
                    "hoursminutes(date_heure):T",
                    title="Heure",
                    axis=alt.Axis(bandPosition=0),
                ),
                y=alt.Y(
                    "note_gene",
                    title="Note de gêne",
                    scale=alt.Scale(zero=True, domainMax=10),
                ),
                color=alt.Color("nb_participants:N", title="Nombre de participant"),
                size="nb_participants:N",
            )
        )


def graphComparaisonBruitDecla(
    dfBruit6Min,
    dfRessenti6min,
    dfNbParticipantParJour,
    title,
    loessBandWith=0.005,
    hauteur=250,
    width=1200,
    loessSize=5,
):
    """
    créer une cahrt en 4 niveaux, avec l'indicateur Leq, la note pondrée, le cumul des notes, le nombre de participants
    Chaque sous chart se compose de point et d'une regression discrete de type LOESS
    in:
        dfBruit6Min, dfRessenti6min, dfNbParticipantParJourloessBandWith : df spécifique à chaque thématique avec un attribu de teps de type epoch

    """
    title = alt.TitleParams(
        title, align="center", anchor="middle", fontWeight="bold", fontSize=14
    )
    checkAttributsinDf(dfBruit6Min, ["epoch", "leq_a"])
    checkAttributsinDf(dfRessenti6min, ["epoch", "moy_pond_sur_k", "note_cumul"])
    checkAttributsinDf(dfNbParticipantParJour, ["epoch", "nb_participants"])
    # chain ede caractèredes dates en abscisse
    labelExpr = "format(date(timeOffset('seconds', utc(1970,1,1,0,0,0), datum.value)),'.2')+'/'+format(month(timeOffset('seconds', utc(1970,1,1,0,0,0), datum.value)),'.2')"
    # graph général des données de bruit
    chartNiveauBruit = (
        alt.Chart(dfBruit6Min)
        .mark_point(opacity=0.2)
        .encode(
            x=alt.X(
                "epoch",
                scale=alt.Scale(zero=False),
                axis=alt.Axis(labelExpr=labelExpr),
                title="date",
            ),
            y=alt.Y(
                "leq_a",
                scale=alt.Scale(zero=False, domainMax=70, clamp=True),
                title="Indicateur Leq_a",
            ),
        )
        .properties(width=width, height=hauteur)
    )
    loessNiveauBruit = chartNiveauBruit.transform_loess(
        "epoch", "leq_a", bandwidth=loessBandWith
    ).mark_line(color="green", size=loessSize)
    chartNiveauBruitTot = chartNiveauBruit + loessNiveauBruit
    # graph général des donnée de ressenti
    chartRessentiMoyPond = (
        alt.Chart(dfRessenti6min)
        .mark_point(opacity=0.2)
        .encode(
            x=alt.X(
                "epoch",
                scale=alt.Scale(zero=False),
                axis=alt.Axis(labelExpr=labelExpr),
                title="date",
            ),
            y=alt.Y(
                "moy_pond_sur_k",
                scale=alt.Scale(zero=False),
                title="Moyenne pondérée des notes de gêne",
            ),
        )
        .properties(width=width, height=hauteur)
    )
    loessRessentiMoyPond = chartRessentiMoyPond.transform_loess(
        "epoch", "moy_pond_sur_k", bandwidth=loessBandWith
    )
    chartRessentiMoyPondTot = chartRessentiMoyPond + loessRessentiMoyPond.mark_line(
        color="green", size=loessSize
    )
    chartRessentiNoteCumul = (
        alt.Chart(dfRessenti6min)
        .mark_point(opacity=0.2)
        .encode(
            x=alt.X(
                "epoch",
                scale=alt.Scale(zero=False),
                axis=alt.Axis(labelExpr=labelExpr),
                title="date",
            ),
            y=alt.Y(
                "note_cumul",
                scale=alt.Scale(zero=False),
                title="Cumul des notes de gêne",
            ),
        )
        .properties(width=width, height=hauteur)
    )
    loessNoteCumul = chartRessentiNoteCumul.transform_loess(
        "epoch", "note_cumul", bandwidth=loessBandWith
    )
    chartRessentiNoteCumulTot = chartRessentiNoteCumul + loessNoteCumul.mark_line(
        color="green", size=loessSize
    )
    chartRessentiNbParticipant = (
        alt.Chart(dfNbParticipantParJour)
        .mark_point(opacity=0.2, filled=True)
        .encode(
            x=alt.X(
                "epoch",
                scale=alt.Scale(zero=False),
                axis=alt.Axis(labelExpr=labelExpr),
                title="date",
            ),
            y=alt.Y(
                "nb_participants",
                scale=alt.Scale(zero=True),
                title="Nombre de participants",
            ),
        )
        .properties(width=width, height=hauteur)
    )
    return (
        chartNiveauBruitTot
        & chartRessentiMoyPondTot
        & chartRessentiNoteCumulTot
        & chartRessentiNbParticipant
    ).properties(title=title)


def graphHarmonica(dfHarmonica):
    """
    créer le graph de représentation de l'indicateur, avec un slider par jour
    """

    def couleurHarmonica(date_heure, harmonica):
        """
        ajouter une colonne decsriptive de la couleur à utiliser pour représenter l'indice
        """
        if ((date_heure.hour >= 22 or date_heure.hour < 6) and harmonica < 3) or (
            (date_heure.hour >= 6 or date_heure.hour < 22) and harmonica < 4
        ):
            return "green"
        elif (
            (date_heure.hour >= 22 or date_heure.hour < 6)
            and (harmonica >= 3 and harmonica < 7)
        ) or (
            (date_heure.hour >= 6 or date_heure.hour < 22)
            and (harmonica >= 4 and harmonica < 8)
        ):
            return "orange"
        elif ((date_heure.hour >= 22 or date_heure.hour < 6) and harmonica >= 7) or (
            (date_heure.hour >= 6 or date_heure.hour < 22) and harmonica >= 8
        ):
            return "red"
        else:
            raise NotImplementedError("cas non prévu")

    dfHarmonica = dfHarmonica.assign(
        couleurharmonica=dfHarmonica.apply(
            lambda x: couleurHarmonica(x.date_heure, x.harmonica), axis=1
        )
    )
    dfHarmonica = dfHarmonica.assign(
        heure_minute=dfHarmonica.date_heure.apply(lambda x: f"{x.strftime('%H:%M')}"),
        jour=dfHarmonica.date_heure.apply(lambda x: x.strftime("%A %d %B %Y")),
        jour_sort=dfHarmonica.date_heure.dt.dayofyear,
    )

    # pour créer les slider
    slider = alt.binding_range(min=80, max=109, step=1)
    select_day = alt.selection_single(
        name="jour_sort", fields=["jour_sort"], bind=slider, init={"jour_sort": 80}
    )
    # graphs
    return (
        (
            alt.Chart(dfHarmonica)
            .mark_bar(width=10)
            .encode(
                x=alt.X("date_heure:T", title="période"),
                y=alt.Y(
                    "bgn", title="indicateur Harmonica", scale=alt.Scale(domain=(0, 10))
                ),
                color=alt.Color("couleurharmonica", scale=None),
            )
            + alt.Chart(dfHarmonica)
            .mark_bar(yOffset=3, y2Offset=-2, color="green", width=10)
            .encode(
                x="date_heure:T",
                y=alt.Y("harmonica"),
                y2="bgn",
                color=alt.Color("couleurharmonica", scale=None),
            )
            + alt.Chart(dfHarmonica)
            .mark_point(shape="triangle-up", filled=True, size=130)
            .encode(
                x="date_heure:T",
                y="harmonica",
                color=alt.Color("couleurharmonica", scale=None),
            )
        )
        .add_selection(select_day)
        .transform_filter(select_day)
        .properties(title="Indicateur Harmonica selon la période de la journée")
    )
