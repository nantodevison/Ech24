# -*- coding: utf-8 -*-
'''
Created on 30 mars 2023

@author: martin.schoreisz
module d'analyse des resultats de declaration traites dans le module Import_stockage_donnees.Import_export_bdd.
'''

import pandas as pd
import numpy as np
from datetime import timedelta
from Outils.Outils import checkParamValues, dateTexteDepuisDayOfYear, checkAttributsinDf
import altair as alt
from collections import Counter
from math import log


def filtrerDeclas(instanceResultatsEnquete, dateDebut="2022-03-21", dateFin="2022-04-17", dureeMaxiDeclaEnHeure=24,
                  typeDeBruit="Bruit routier"):
    """
    limite les donnees  la periode de mesures et aux declaration qui ne couvrent pas l'ensemble de la periode
    in : 
        instanceResultatsEnquete instance de la classe Import_stockage_donnees.Import_export_bdd.ResultatsEnquete
        dateDebut : string format YYYY-MM-DD : date de debut de la collecte
        dateFin : string format YYYY-MM-DD : date de fin de la collecte
        dureeMaxiDeclaEnHeure : integer : duree maximale en heure totale pour une declaration. Au dela la decla est filtre
    out : 
        data farme sur le modele de ResultatsEnquete.declarations_ok
    """
    checkParamValues(typeDeBruit, ('Bruit routier', "Bruit de voisinage","Bruit de chantier", 'Autre'))
    return instanceResultatsEnquete.declarations_ok.loc[
    (
        instanceResultatsEnquete.declarations_ok.debut_gene.dt.date.isin(
            [e.date() for e in pd.date_range(dateDebut, dateFin)]
        )
    )
    & (instanceResultatsEnquete.declarations_ok.duree_gene < timedelta(hours=dureeMaxiDeclaEnHeure))
    & (
        instanceResultatsEnquete.declarations_ok.source_bruit.apply(
            lambda x: typeDeBruit in x if x else True
        )
    )].copy()
    
    
def passageDeclas6min(dfDecla, dateDebut="2022-03-21", dateFin="2022-04-18", annee=2022, pasTemporel="6 min"):
    """
    passage des donnees de declaration en debut / fin vers des donnees a intervalles regulier 
    in :
       dfDecla : dataframe issue de  filtrerDeclas
    """
    checkAttributsinDf(dfDecla, ['debut_gene', 'fin_gene'])
    dfToutTemps = dfDecla.merge(
        pd.Series(
            pd.date_range(dateDebut, dateFin, freq=pasTemporel), name="date_heure"
        ),
        how="cross",
    )
    dfToutTemps = dfToutTemps.loc[
        (dfToutTemps.date_heure >= dfToutTemps.debut_gene)
        & (dfToutTemps.date_heure <= dfToutTemps.fin_gene)
    ].copy()
    dfToutTemps["date_gene"] = dfToutTemps.date_heure.dt.dayofyear
    dfToutTemps["date_gene_texte"] = dfToutTemps.date_gene.apply(
        lambda x: dateTexteDepuisDayOfYear(x, annee, formatSortie="%A %d %B")
    )
    return dfToutTemps


def grouperDeclaParHorodate(dfDecla6Min):
    """
    Agrégation des données de façon à n'avoir qu'une seule ligne par par de 6 minutes
    on va calculer les indicateurs statistiques classiques : écart_type min, max, moyenne, nombre de vote
    on ne pernd pas la médiane, car les votes "extrême" reste des informatiosn à ne pas considérer comme déviantes
    in:
        dfDecla6Min : df issue de passageDeclas6min
    out :  
        df avec une seule ligne par horodate et des agregats
    """
    dfToutTempsIndics = (
        dfDecla6Min.groupby("date_heure")
        .note_gene.agg(
            [
                np.std,
                lambda x: tuple(x),
                np.mean,
                lambda x: len(x),
                lambda x: Counter(x),
                np.min,
                np.max,
                np.var,
            ]
        )
        .rename(
            columns={
                "std": "ecart_type",
                "<lambda_0>": "valeurs",
                "mean": "moyenne",
                "<lambda_1>": "nb_val",
                "<lambda_2>": "nb_occ",
                "amin": "note_min",
                "amax": "note_max",
            }
        )
        .reset_index()
    )
    # analyse d'un jour
    dfToutTempsIndics["date_gene"] = dfToutTempsIndics.date_heure.dt.dayofyear
    return dfToutTempsIndics


def ajouterIndicateursTest(dfDecla6MinGroupee):
    """
    ajouter les attributs de cumul des notes, cumul de note ponderees, moyenne pondérée, moyenne pondérée avec note note pondérée,
    moyenne pondérée avec pondération pondérée
    """
    dfToutTempsIndics = dfDecla6MinGroupee.copy()
    dfToutTempsIndics["note_cumul"] = dfToutTempsIndics.nb_occ.apply(
        lambda x: sum([k * v for k, v in x.items()])
    )
    dfToutTempsIndics["note_pondere_std"] = dfToutTempsIndics.apply(
        lambda x: (
            1.5
            / (
                x.ecart_type
                if (not pd.isnull(x.ecart_type) and x.ecart_type != 0)
                else 1.5 - (x.nb_val * 0.1)
            )
        )
        * x.nb_val
        * x.moyenne,
        axis=1,
    )
    dfToutTempsIndics["nb_note"] = dfToutTempsIndics.nb_occ.apply(
        lambda x: sum([v for v in x.values()])
    )
    dfMoyennePonderee = dfToutTempsIndics.assign(
        moy_pond_sur_k=dfToutTempsIndics.apply(
            lambda x: (sum([(k + log(v / 2)) * pow(v, 2) for k, v in x.nb_occ.items()]))
            / sum([pow(v, 2) for v in x.nb_occ.values()]),
            axis=1,
        ),
        moy_pond_sur_v=dfToutTempsIndics.apply(
            lambda x: (sum([(k) * pow(v + log(v / 2), 2) for k, v in x.nb_occ.items()]))
            / sum([pow(v + log(v / 2), 2) for v in x.nb_occ.values()]),
            axis=1,
        ),
        moy_pond=dfToutTempsIndics.apply(
            lambda x: (sum([(k) * pow(v, 2) for k, v in x.nb_occ.items()]))
            / sum([pow(v, 2) for v in x.nb_occ.values()]),
            axis=1,
        )
    )
    return dfMoyennePonderee


def ajouterMoyennePonderee(dfDecla6MinGroupee, nbVotantRepresentatif=2):
    """
    ajouter la moyenne pondérée par terme correctif sur la note en fonction du nombre de votant.
    in: 
        nbVotantRepresentatif : nombre de votant à partir duquel on considère que la note est représentative
    """
    checkAttributsinDf(dfDecla6MinGroupee, 'nb_occ')
    dfDecla6MinGroupee[f'moy_pond_{nbVotantRepresentatif}Votants'] = dfDecla6MinGroupee.apply(
            lambda x: (sum([(k + log(v / nbVotantRepresentatif)) * pow(v, nbVotantRepresentatif) for k, v in x.nb_occ.items()]))
            / sum([pow(v, nbVotantRepresentatif) for v in x.nb_occ.values()]),
            axis=1,
        )
    return dfDecla6MinGroupee


def graphNbVotantParJour(dfDecla6Min):    
    """
    creer le graph de visu du nombre de votant par jour
    in:
        dfDecla6Min : df issue de passageDeclas6min
    out:
        chart altair
    """ 
    # mise en forme des données
    dfNbParticipantParJour = (
        dfDecla6Min.drop_duplicates(["date_gene", "id_participant"])
        .groupby(["date_gene", "date_gene_texte"])
        .id_participant.count()
        .reset_index()
    )
    # chart nombre de participants par jour
    chartEvolNbParticipantsParJour = (
        alt.Chart(dfNbParticipantParJour, title="Nombre de participants par jour")
        .mark_line()
        .encode(
            x=alt.X("date_gene_texte", title=None, sort=alt.SortField("date_gene")),
            y=alt.Y("id_participant", title="Nombre de participants par jour"),
        )
    )
    return chartEvolNbParticipantsParJour


def graphEvolutionMoyMinMaxStd(dfDecla6MinGroupee, domain=(0, 10), largeur=1200, hauteur=400):
    """
    graph sur l'ensemble de la période de mesure, présentant les variations de notes fournies
    in : 
        dfDecla6MinGroupee : df issue de grouperDeclaParHorodate()
    out:
        chart altair
    """
    base = alt.Chart(dfDecla6MinGroupee).encode(x=alt.X("date_heure:T", title="Date"))
    noteMoyenne = base.mark_trail().encode(
        y=alt.Y("moyenne", title="Note", scale=alt.Scale(zero=True, domain=domain)),
        size=alt.Size(
            "nb_val",
            title=["Nombre de", "déclarations"],
            scale=alt.Scale(rangeMin=0.7, rangeMax=6),
        ),
    )
    rangeNote = base.mark_area(opacity=0.5, color="#BCBCBC").encode(
        y=alt.Y("note_max", title="Note", scale=alt.Scale(domain=domain)), y2="note_min"
    )
    ecartType = base.mark_line(color="black").encode(
        y=alt.Y("ecart_type", title="Note", scale=alt.Scale(domain=domain))
    )
    return (noteMoyenne + rangeNote + ecartType).properties(
        title=[
            "Évolution de la moyenne, du maximum et du minimum des notes",
            "ainsi que de l'écart type",
        ],
        width=largeur,
        height=hauteur,
    )
    
    
def graphMoyennesPonderees(dfMoyennePonderee, listAttributs=["moyenne", "moy_pond", "moy_pond_sur_k", "moy_pond_sur_v"],
                           largeur=500, domain=(4, 10)):
    """
    création du graph représentant une ou plusieurs moyennes pondérées
    in:
       dfMoyennePonderee: datafarme issue de  ajouterIndicateursTest
       listAttributs : list de string des attributs à représenter
       domain : tuple de int : domaine de valeur sur l'axe y
    """
    return (alt.Chart(dfMoyennePonderee, width=largeur)
                .transform_fold(listAttributs)
                .mark_line()
                .encode(
                    x=alt.X("date_heure:T"),
                    y=alt.Y("value:Q", scale=alt.Scale(domain=domain)),
                    color="key:N",
                ))
    
    
def creerChartDeclaHeureMinute(
        df, noteCumulee=True, largeur=500, hauteur=200, domainMax=120
    ):
        """
        créer une chart qui va compiler le nombre de déclaration de gene, pour une note données
        à un moment donnée d'une journée donnée. Si envie peux aussi fournir une note cumulée
        in :
            df : doit contenir les attributs 'id_participant', 'date_heure', 'note_gene', 'date_gene_texte'
        """
        titre = ["Gêne selon la journée"]
        dfGroupee = (
            df[
                [
                    "id_participant",
                    "date_heure",
                    "note_gene",
                    "date_gene_texte",
                    "date_gene",
                ]
            ]
            .groupby(["date_heure", "note_gene", "date_gene_texte", "date_gene"])
            .id_participant.count()
            .reset_index()
            .sort_values("date_heure")
            .rename(columns={"id_participant": "nb_participants"})
        )
        if noteCumulee:
            dfNoteCumulee = (
                dfGroupee.groupby(["date_heure", "date_gene_texte", "date_gene"])
                .apply(
                    lambda x: sum([n * p for n, p in zip(x.note_gene, x.nb_participants)])
                )
                .reset_index()
                .rename(columns={0: "coeff_pondere"})
            )
            dfMergee = dfGroupee.merge(
                dfNoteCumulee[["date_heure", "coeff_pondere"]], on="date_heure"
            )
            baseChart = alt.Chart(
                dfMergee, width=largeur, height=hauteur, title=titre
            ).encode(
                x=alt.X(
                    "hoursminutes(date_heure):T",
                    title="Heure",
                    axis=alt.Axis(bandPosition=0),
                )
            )
            chartNbDecla = baseChart.mark_circle().encode(
                y=alt.Y(
                    "note_gene",
                    title="Note de gêne",
                    scale=alt.Scale(zero=True, domainMax=10),
                ),
                color=alt.Color("nb_participants:N", title="Nombre de participant"),
                size="nb_participants:N",
            )
            chartNoteCumulee = baseChart.mark_line(color="black").encode(
                x=alt.X(
                    "hoursminutes(date_heure):T",
                    title="Heure",
                    axis=alt.Axis(bandPosition=0),
                ),
                y=alt.Y(
                    "coeff_pondere",
                    title="Coefficient pondéré",
                    scale=alt.Scale(zero=True, domainMax=domainMax),
                ),
            )
            return (
                (chartNbDecla + chartNoteCumulee)
                .resolve_scale(y="independent")
                .resolve_axis(x="shared")
            )
        else:
            return (
                alt.Chart(dfGroupee, width=largeur, height=hauteur, title=titre)
                .mark_circle()
                .encode(
                    x=alt.X(
                        "hoursminutes(date_heure):T",
                        title="Heure",
                        axis=alt.Axis(bandPosition=0),
                    ),
                    y=alt.Y(
                        "note_gene",
                        title="Note de gêne",
                        scale=alt.Scale(zero=True, domainMax=10),
                    ),
                    color=alt.Color("nb_participants:N", title="Nombre de participant"),
                    size="nb_participants:N",
                )
            )
    
    
    
    
